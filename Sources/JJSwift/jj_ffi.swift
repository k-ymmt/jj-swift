// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(jj_ffiFFI)
import jj_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_jj_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_jj_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}




/**
 * A Git transaction for performing Git operations
 *
 * This wraps a jj Transaction and provides Git-specific operations.
 */
public protocol FfiGitTransactionProtocol : AnyObject {
    
    /**
     * Commit the git transaction and return the updated repository
     */
    func commit(description: String) throws  -> FfiReadonlyRepo
    
    /**
     * Discard the git transaction without committing
     */
    func discard() throws 
    
    /**
     * Export refs to the underlying Git repository
     *
     * This synchronizes the Git refs with changes made in jj.
     */
    func exportRefs() throws  -> FfiGitExportStats
    
    /**
     * Fetch from a remote
     *
     * Fetches the specified branches (or all branches if empty) from the remote.
     */
    func fetch(remoteName: String, branchPatterns: [String]) throws  -> FfiGitImportStats
    
    /**
     * Import refs from the underlying Git repository
     *
     * This synchronizes the jj view with any changes made directly in Git.
     */
    func importRefs() throws  -> FfiGitImportStats
    
    /**
     * Push branches to a remote
     *
     * Pushes the specified local branches to the remote.
     */
    func pushBranches(remoteName: String, branchNames: [String]) throws  -> FfiGitPushStats
    
}

/**
 * A Git transaction for performing Git operations
 *
 * This wraps a jj Transaction and provides Git-specific operations.
 */
open class FfiGitTransaction:
    FfiGitTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_jj_ffi_fn_clone_ffigittransaction(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_jj_ffi_fn_free_ffigittransaction(pointer, $0) }
    }

    

    
    /**
     * Commit the git transaction and return the updated repository
     */
open func commit(description: String)throws  -> FfiReadonlyRepo {
    return try  FfiConverterTypeFfiReadonlyRepo.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_commit(self.uniffiClonePointer(),
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * Discard the git transaction without committing
     */
open func discard()throws  {try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_discard(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Export refs to the underlying Git repository
     *
     * This synchronizes the Git refs with changes made in jj.
     */
open func exportRefs()throws  -> FfiGitExportStats {
    return try  FfiConverterTypeFfiGitExportStats.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_export_refs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Fetch from a remote
     *
     * Fetches the specified branches (or all branches if empty) from the remote.
     */
open func fetch(remoteName: String, branchPatterns: [String])throws  -> FfiGitImportStats {
    return try  FfiConverterTypeFfiGitImportStats.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_fetch(self.uniffiClonePointer(),
        FfiConverterString.lower(remoteName),
        FfiConverterSequenceString.lower(branchPatterns),$0
    )
})
}
    
    /**
     * Import refs from the underlying Git repository
     *
     * This synchronizes the jj view with any changes made directly in Git.
     */
open func importRefs()throws  -> FfiGitImportStats {
    return try  FfiConverterTypeFfiGitImportStats.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_import_refs(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Push branches to a remote
     *
     * Pushes the specified local branches to the remote.
     */
open func pushBranches(remoteName: String, branchNames: [String])throws  -> FfiGitPushStats {
    return try  FfiConverterTypeFfiGitPushStats.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffigittransaction_push_branches(self.uniffiClonePointer(),
        FfiConverterString.lower(remoteName),
        FfiConverterSequenceString.lower(branchNames),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGitTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiGitTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGitTransaction {
        return FfiGitTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiGitTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGitTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiGitTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiGitTransaction {
    return try FfiConverterTypeFfiGitTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitTransaction_lower(_ value: FfiGitTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiGitTransaction.lower(value)
}




/**
 * A readonly repository exposed via FFI
 */
public protocol FfiReadonlyRepoProtocol : AnyObject {
    
    /**
     * Count commits matching a revset expression
     */
    func countRevset(revsetStr: String, userEmail: String) throws  -> UInt64
    
    /**
     * Evaluate a revset expression and return matching commit IDs
     */
    func evaluateRevset(revsetStr: String, userEmail: String) throws  -> [FfiCommitId]
    
    /**
     * Evaluate a revset expression and return matching commits
     */
    func evaluateRevsetToCommits(revsetStr: String, userEmail: String) throws  -> [FfiCommit]
    
    /**
     * Get a commit by its commit ID (hex string)
     */
    func getCommit(commitId: FfiCommitId) throws  -> FfiCommit
    
    /**
     * Resolve a change ID to commit IDs
     */
    func resolveChangeId(changeId: FfiChangeId) throws  -> [FfiCommitId]
    
    /**
     * Resolve a commit ID prefix (returns all matching commits)
     */
    func resolveCommitPrefix(prefix: String) throws  -> [FfiCommitId]
    
    /**
     * Get the root change ID
     */
    func rootChangeId()  -> FfiChangeId
    
    /**
     * Get the root commit of the repository
     */
    func rootCommit()  -> FfiCommit
    
    /**
     * Get the root commit ID
     */
    func rootCommitId()  -> FfiCommitId
    
    /**
     * Start a new Git transaction for performing Git operations
     */
    func startGitTransaction() throws  -> FfiGitTransaction
    
    /**
     * Start a new transaction for making changes to the repository
     */
    func startTransaction()  -> FfiTransaction
    
}

/**
 * A readonly repository exposed via FFI
 */
open class FfiReadonlyRepo:
    FfiReadonlyRepoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_jj_ffi_fn_clone_ffireadonlyrepo(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_jj_ffi_fn_free_ffireadonlyrepo(pointer, $0) }
    }

    

    
    /**
     * Count commits matching a revset expression
     */
open func countRevset(revsetStr: String, userEmail: String)throws  -> UInt64 {
    return try  FfiConverterUInt64.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_count_revset(self.uniffiClonePointer(),
        FfiConverterString.lower(revsetStr),
        FfiConverterString.lower(userEmail),$0
    )
})
}
    
    /**
     * Evaluate a revset expression and return matching commit IDs
     */
open func evaluateRevset(revsetStr: String, userEmail: String)throws  -> [FfiCommitId] {
    return try  FfiConverterSequenceTypeFfiCommitId.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_evaluate_revset(self.uniffiClonePointer(),
        FfiConverterString.lower(revsetStr),
        FfiConverterString.lower(userEmail),$0
    )
})
}
    
    /**
     * Evaluate a revset expression and return matching commits
     */
open func evaluateRevsetToCommits(revsetStr: String, userEmail: String)throws  -> [FfiCommit] {
    return try  FfiConverterSequenceTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_evaluate_revset_to_commits(self.uniffiClonePointer(),
        FfiConverterString.lower(revsetStr),
        FfiConverterString.lower(userEmail),$0
    )
})
}
    
    /**
     * Get a commit by its commit ID (hex string)
     */
open func getCommit(commitId: FfiCommitId)throws  -> FfiCommit {
    return try  FfiConverterTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_get_commit(self.uniffiClonePointer(),
        FfiConverterTypeFfiCommitId.lower(commitId),$0
    )
})
}
    
    /**
     * Resolve a change ID to commit IDs
     */
open func resolveChangeId(changeId: FfiChangeId)throws  -> [FfiCommitId] {
    return try  FfiConverterSequenceTypeFfiCommitId.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_resolve_change_id(self.uniffiClonePointer(),
        FfiConverterTypeFfiChangeId.lower(changeId),$0
    )
})
}
    
    /**
     * Resolve a commit ID prefix (returns all matching commits)
     */
open func resolveCommitPrefix(prefix: String)throws  -> [FfiCommitId] {
    return try  FfiConverterSequenceTypeFfiCommitId.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_resolve_commit_prefix(self.uniffiClonePointer(),
        FfiConverterString.lower(prefix),$0
    )
})
}
    
    /**
     * Get the root change ID
     */
open func rootChangeId() -> FfiChangeId {
    return try!  FfiConverterTypeFfiChangeId.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_root_change_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the root commit of the repository
     */
open func rootCommit() -> FfiCommit {
    return try!  FfiConverterTypeFfiCommit.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_root_commit(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the root commit ID
     */
open func rootCommitId() -> FfiCommitId {
    return try!  FfiConverterTypeFfiCommitId.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_root_commit_id(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Start a new Git transaction for performing Git operations
     */
open func startGitTransaction()throws  -> FfiGitTransaction {
    return try  FfiConverterTypeFfiGitTransaction.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_start_git_transaction(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Start a new transaction for making changes to the repository
     */
open func startTransaction() -> FfiTransaction {
    return try!  FfiConverterTypeFfiTransaction.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffireadonlyrepo_start_transaction(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiReadonlyRepo: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiReadonlyRepo

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiReadonlyRepo {
        return FfiReadonlyRepo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiReadonlyRepo) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiReadonlyRepo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiReadonlyRepo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReadonlyRepo_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiReadonlyRepo {
    return try FfiConverterTypeFfiReadonlyRepo.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiReadonlyRepo_lower(_ value: FfiReadonlyRepo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiReadonlyRepo.lower(value)
}




/**
 * A transaction for making changes to a repository
 *
 * # Safety
 * The Transaction type from jj-lib is not Send + Sync, but we wrap it in a Mutex
 * to ensure synchronized access. All FFI operations acquire the lock before accessing
 * the transaction.
 */
public protocol FfiTransactionProtocol : AnyObject {
    
    /**
     * Abandon a commit (its children will be rebased to its parents)
     */
    func abandonCommit(commitId: FfiCommitId) throws 
    
    /**
     * Commit the transaction and return the updated repository
     */
    func commit(description: String) throws  -> FfiReadonlyRepo
    
    /**
     * Create a new commit with the same tree as a parent commit
     */
    func createCommitFromParent(parentId: FfiCommitId, description: String) throws  -> FfiCommit
    
    /**
     * Create a new commit with an empty tree (for creating empty commits)
     */
    func createEmptyCommit(newCommit: FfiNewCommit) throws  -> FfiCommit
    
    /**
     * Discard the transaction without committing
     */
    func discard() throws 
    
    /**
     * Check if the transaction has any uncommitted changes
     */
    func hasChanges() throws  -> Bool
    
    /**
     * Rewrite an existing commit with new properties
     */
    func rewriteCommit(rewrite: FfiRewriteCommit) throws  -> FfiCommit
    
    /**
     * Update the description of an existing commit
     */
    func updateDescription(commitId: FfiCommitId, newDescription: String) throws  -> FfiCommit
    
}

/**
 * A transaction for making changes to a repository
 *
 * # Safety
 * The Transaction type from jj-lib is not Send + Sync, but we wrap it in a Mutex
 * to ensure synchronized access. All FFI operations acquire the lock before accessing
 * the transaction.
 */
open class FfiTransaction:
    FfiTransactionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_jj_ffi_fn_clone_ffitransaction(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_jj_ffi_fn_free_ffitransaction(pointer, $0) }
    }

    

    
    /**
     * Abandon a commit (its children will be rebased to its parents)
     */
open func abandonCommit(commitId: FfiCommitId)throws  {try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_abandon_commit(self.uniffiClonePointer(),
        FfiConverterTypeFfiCommitId.lower(commitId),$0
    )
}
}
    
    /**
     * Commit the transaction and return the updated repository
     */
open func commit(description: String)throws  -> FfiReadonlyRepo {
    return try  FfiConverterTypeFfiReadonlyRepo.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_commit(self.uniffiClonePointer(),
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * Create a new commit with the same tree as a parent commit
     */
open func createCommitFromParent(parentId: FfiCommitId, description: String)throws  -> FfiCommit {
    return try  FfiConverterTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_create_commit_from_parent(self.uniffiClonePointer(),
        FfiConverterTypeFfiCommitId.lower(parentId),
        FfiConverterString.lower(description),$0
    )
})
}
    
    /**
     * Create a new commit with an empty tree (for creating empty commits)
     */
open func createEmptyCommit(newCommit: FfiNewCommit)throws  -> FfiCommit {
    return try  FfiConverterTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_create_empty_commit(self.uniffiClonePointer(),
        FfiConverterTypeFfiNewCommit.lower(newCommit),$0
    )
})
}
    
    /**
     * Discard the transaction without committing
     */
open func discard()throws  {try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_discard(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Check if the transaction has any uncommitted changes
     */
open func hasChanges()throws  -> Bool {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_has_changes(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Rewrite an existing commit with new properties
     */
open func rewriteCommit(rewrite: FfiRewriteCommit)throws  -> FfiCommit {
    return try  FfiConverterTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_rewrite_commit(self.uniffiClonePointer(),
        FfiConverterTypeFfiRewriteCommit.lower(rewrite),$0
    )
})
}
    
    /**
     * Update the description of an existing commit
     */
open func updateDescription(commitId: FfiCommitId, newDescription: String)throws  -> FfiCommit {
    return try  FfiConverterTypeFfiCommit.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_method_ffitransaction_update_description(self.uniffiClonePointer(),
        FfiConverterTypeFfiCommitId.lower(commitId),
        FfiConverterString.lower(newDescription),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTransaction: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiTransaction

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiTransaction {
        return FfiTransaction(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiTransaction) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTransaction {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiTransaction, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransaction_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiTransaction {
    return try FfiConverterTypeFfiTransaction.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTransaction_lower(_ value: FfiTransaction) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiTransaction.lower(value)
}




/**
 * A workspace exposed via FFI
 */
public protocol FfiWorkspaceProtocol : AnyObject {
    
    /**
     * Get a readonly repository handle
     */
    func repo()  -> FfiReadonlyRepo
    
    /**
     * Get the repo path
     */
    func repoPath()  -> String
    
    /**
     * Get the workspace root path
     */
    func workspaceRoot()  -> String
    
}

/**
 * A workspace exposed via FFI
 */
open class FfiWorkspace:
    FfiWorkspaceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_jj_ffi_fn_clone_ffiworkspace(self.pointer, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_jj_ffi_fn_free_ffiworkspace(pointer, $0) }
    }

    
    /**
     * Load an existing workspace from the given path
     */
public static func load(workspacePath: String, userName: String, userEmail: String)throws  -> FfiWorkspace {
    return try  FfiConverterTypeFfiWorkspace.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_constructor_ffiworkspace_load(
        FfiConverterString.lower(workspacePath),
        FfiConverterString.lower(userName),
        FfiConverterString.lower(userEmail),$0
    )
})
}
    

    
    /**
     * Get a readonly repository handle
     */
open func repo() -> FfiReadonlyRepo {
    return try!  FfiConverterTypeFfiReadonlyRepo.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffiworkspace_repo(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the repo path
     */
open func repoPath() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffiworkspace_repo_path(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get the workspace root path
     */
open func workspaceRoot() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_jj_ffi_fn_method_ffiworkspace_workspace_root(self.uniffiClonePointer(),$0
    )
})
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiWorkspace: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FfiWorkspace

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWorkspace {
        return FfiWorkspace(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FfiWorkspace) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiWorkspace {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FfiWorkspace, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWorkspace_lift(_ pointer: UnsafeMutableRawPointer) throws -> FfiWorkspace {
    return try FfiConverterTypeFfiWorkspace.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiWorkspace_lower(_ value: FfiWorkspace) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFfiWorkspace.lower(value)
}


/**
 * A change ID represented as a reverse-hex string for FFI
 */
public struct FfiChangeId {
    /**
     * Reverse-hex encoded change ID (z-k digits)
     */
    public var hex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Reverse-hex encoded change ID (z-k digits)
         */hex: String) {
        self.hex = hex
    }
}



extension FfiChangeId: Equatable, Hashable {
    public static func ==(lhs: FfiChangeId, rhs: FfiChangeId) -> Bool {
        if lhs.hex != rhs.hex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiChangeId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiChangeId {
        return
            try FfiChangeId(
                hex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiChangeId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.hex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiChangeId_lift(_ buf: RustBuffer) throws -> FfiChangeId {
    return try FfiConverterTypeFfiChangeId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiChangeId_lower(_ value: FfiChangeId) -> RustBuffer {
    return FfiConverterTypeFfiChangeId.lower(value)
}


/**
 * A commit exposed via FFI
 */
public struct FfiCommit {
    /**
     * The commit ID (content-based hash)
     */
    public var id: FfiCommitId
    /**
     * The change ID (stable identifier across rewrites)
     */
    public var changeId: FfiChangeId
    /**
     * Commit description/message
     */
    public var description: String
    /**
     * Author signature
     */
    public var author: FfiSignature
    /**
     * Committer signature
     */
    public var committer: FfiSignature
    /**
     * Parent commit IDs
     */
    public var parentIds: [FfiCommitId]
    /**
     * Whether this commit is signed
     */
    public var isSigned: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The commit ID (content-based hash)
         */id: FfiCommitId, 
        /**
         * The change ID (stable identifier across rewrites)
         */changeId: FfiChangeId, 
        /**
         * Commit description/message
         */description: String, 
        /**
         * Author signature
         */author: FfiSignature, 
        /**
         * Committer signature
         */committer: FfiSignature, 
        /**
         * Parent commit IDs
         */parentIds: [FfiCommitId], 
        /**
         * Whether this commit is signed
         */isSigned: Bool) {
        self.id = id
        self.changeId = changeId
        self.description = description
        self.author = author
        self.committer = committer
        self.parentIds = parentIds
        self.isSigned = isSigned
    }
}



extension FfiCommit: Equatable, Hashable {
    public static func ==(lhs: FfiCommit, rhs: FfiCommit) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.changeId != rhs.changeId {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.author != rhs.author {
            return false
        }
        if lhs.committer != rhs.committer {
            return false
        }
        if lhs.parentIds != rhs.parentIds {
            return false
        }
        if lhs.isSigned != rhs.isSigned {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(changeId)
        hasher.combine(description)
        hasher.combine(author)
        hasher.combine(committer)
        hasher.combine(parentIds)
        hasher.combine(isSigned)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCommit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCommit {
        return
            try FfiCommit(
                id: FfiConverterTypeFfiCommitId.read(from: &buf), 
                changeId: FfiConverterTypeFfiChangeId.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                author: FfiConverterTypeFfiSignature.read(from: &buf), 
                committer: FfiConverterTypeFfiSignature.read(from: &buf), 
                parentIds: FfiConverterSequenceTypeFfiCommitId.read(from: &buf), 
                isSigned: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCommit, into buf: inout [UInt8]) {
        FfiConverterTypeFfiCommitId.write(value.id, into: &buf)
        FfiConverterTypeFfiChangeId.write(value.changeId, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterTypeFfiSignature.write(value.author, into: &buf)
        FfiConverterTypeFfiSignature.write(value.committer, into: &buf)
        FfiConverterSequenceTypeFfiCommitId.write(value.parentIds, into: &buf)
        FfiConverterBool.write(value.isSigned, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCommit_lift(_ buf: RustBuffer) throws -> FfiCommit {
    return try FfiConverterTypeFfiCommit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCommit_lower(_ value: FfiCommit) -> RustBuffer {
    return FfiConverterTypeFfiCommit.lower(value)
}


/**
 * A commit ID represented as a hex string for FFI
 */
public struct FfiCommitId {
    /**
     * Hex-encoded commit ID
     */
    public var hex: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded commit ID
         */hex: String) {
        self.hex = hex
    }
}



extension FfiCommitId: Equatable, Hashable {
    public static func ==(lhs: FfiCommitId, rhs: FfiCommitId) -> Bool {
        if lhs.hex != rhs.hex {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hex)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiCommitId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiCommitId {
        return
            try FfiCommitId(
                hex: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FfiCommitId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.hex, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCommitId_lift(_ buf: RustBuffer) throws -> FfiCommitId {
    return try FfiConverterTypeFfiCommitId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiCommitId_lower(_ value: FfiCommitId) -> RustBuffer {
    return FfiConverterTypeFfiCommitId.lower(value)
}


/**
 * Statistics from a git export operation
 */
public struct FfiGitExportStats {
    /**
     * Number of bookmarks that failed to export
     */
    public var failedBookmarksCount: UInt64
    /**
     * Number of tags that failed to export
     */
    public var failedTagsCount: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of bookmarks that failed to export
         */failedBookmarksCount: UInt64, 
        /**
         * Number of tags that failed to export
         */failedTagsCount: UInt64) {
        self.failedBookmarksCount = failedBookmarksCount
        self.failedTagsCount = failedTagsCount
    }
}



extension FfiGitExportStats: Equatable, Hashable {
    public static func ==(lhs: FfiGitExportStats, rhs: FfiGitExportStats) -> Bool {
        if lhs.failedBookmarksCount != rhs.failedBookmarksCount {
            return false
        }
        if lhs.failedTagsCount != rhs.failedTagsCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(failedBookmarksCount)
        hasher.combine(failedTagsCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGitExportStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGitExportStats {
        return
            try FfiGitExportStats(
                failedBookmarksCount: FfiConverterUInt64.read(from: &buf), 
                failedTagsCount: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGitExportStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.failedBookmarksCount, into: &buf)
        FfiConverterUInt64.write(value.failedTagsCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitExportStats_lift(_ buf: RustBuffer) throws -> FfiGitExportStats {
    return try FfiConverterTypeFfiGitExportStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitExportStats_lower(_ value: FfiGitExportStats) -> RustBuffer {
    return FfiConverterTypeFfiGitExportStats.lower(value)
}


/**
 * Statistics from a git import operation
 */
public struct FfiGitImportStats {
    /**
     * Number of commits that were abandoned
     */
    public var abandonedCommitsCount: UInt64
    /**
     * Number of remote bookmarks that changed
     */
    public var changedRemoteBookmarksCount: UInt64
    /**
     * Number of remote tags that changed
     */
    public var changedRemoteTagsCount: UInt64
    /**
     * Number of refs that failed to import
     */
    public var failedRefsCount: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of commits that were abandoned
         */abandonedCommitsCount: UInt64, 
        /**
         * Number of remote bookmarks that changed
         */changedRemoteBookmarksCount: UInt64, 
        /**
         * Number of remote tags that changed
         */changedRemoteTagsCount: UInt64, 
        /**
         * Number of refs that failed to import
         */failedRefsCount: UInt64) {
        self.abandonedCommitsCount = abandonedCommitsCount
        self.changedRemoteBookmarksCount = changedRemoteBookmarksCount
        self.changedRemoteTagsCount = changedRemoteTagsCount
        self.failedRefsCount = failedRefsCount
    }
}



extension FfiGitImportStats: Equatable, Hashable {
    public static func ==(lhs: FfiGitImportStats, rhs: FfiGitImportStats) -> Bool {
        if lhs.abandonedCommitsCount != rhs.abandonedCommitsCount {
            return false
        }
        if lhs.changedRemoteBookmarksCount != rhs.changedRemoteBookmarksCount {
            return false
        }
        if lhs.changedRemoteTagsCount != rhs.changedRemoteTagsCount {
            return false
        }
        if lhs.failedRefsCount != rhs.failedRefsCount {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(abandonedCommitsCount)
        hasher.combine(changedRemoteBookmarksCount)
        hasher.combine(changedRemoteTagsCount)
        hasher.combine(failedRefsCount)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGitImportStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGitImportStats {
        return
            try FfiGitImportStats(
                abandonedCommitsCount: FfiConverterUInt64.read(from: &buf), 
                changedRemoteBookmarksCount: FfiConverterUInt64.read(from: &buf), 
                changedRemoteTagsCount: FfiConverterUInt64.read(from: &buf), 
                failedRefsCount: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGitImportStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.abandonedCommitsCount, into: &buf)
        FfiConverterUInt64.write(value.changedRemoteBookmarksCount, into: &buf)
        FfiConverterUInt64.write(value.changedRemoteTagsCount, into: &buf)
        FfiConverterUInt64.write(value.failedRefsCount, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitImportStats_lift(_ buf: RustBuffer) throws -> FfiGitImportStats {
    return try FfiConverterTypeFfiGitImportStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitImportStats_lower(_ value: FfiGitImportStats) -> RustBuffer {
    return FfiConverterTypeFfiGitImportStats.lower(value)
}


/**
 * Statistics from a git push operation
 */
public struct FfiGitPushStats {
    /**
     * Number of refs that were successfully pushed
     */
    public var pushedCount: UInt64
    /**
     * Number of refs that were rejected (lease failure)
     */
    public var rejectedCount: UInt64
    /**
     * Number of refs that were rejected by the remote
     */
    public var remoteRejectedCount: UInt64
    /**
     * Whether all refs were pushed successfully
     */
    public var allOk: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Number of refs that were successfully pushed
         */pushedCount: UInt64, 
        /**
         * Number of refs that were rejected (lease failure)
         */rejectedCount: UInt64, 
        /**
         * Number of refs that were rejected by the remote
         */remoteRejectedCount: UInt64, 
        /**
         * Whether all refs were pushed successfully
         */allOk: Bool) {
        self.pushedCount = pushedCount
        self.rejectedCount = rejectedCount
        self.remoteRejectedCount = remoteRejectedCount
        self.allOk = allOk
    }
}



extension FfiGitPushStats: Equatable, Hashable {
    public static func ==(lhs: FfiGitPushStats, rhs: FfiGitPushStats) -> Bool {
        if lhs.pushedCount != rhs.pushedCount {
            return false
        }
        if lhs.rejectedCount != rhs.rejectedCount {
            return false
        }
        if lhs.remoteRejectedCount != rhs.remoteRejectedCount {
            return false
        }
        if lhs.allOk != rhs.allOk {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pushedCount)
        hasher.combine(rejectedCount)
        hasher.combine(remoteRejectedCount)
        hasher.combine(allOk)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiGitPushStats: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiGitPushStats {
        return
            try FfiGitPushStats(
                pushedCount: FfiConverterUInt64.read(from: &buf), 
                rejectedCount: FfiConverterUInt64.read(from: &buf), 
                remoteRejectedCount: FfiConverterUInt64.read(from: &buf), 
                allOk: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: FfiGitPushStats, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.pushedCount, into: &buf)
        FfiConverterUInt64.write(value.rejectedCount, into: &buf)
        FfiConverterUInt64.write(value.remoteRejectedCount, into: &buf)
        FfiConverterBool.write(value.allOk, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitPushStats_lift(_ buf: RustBuffer) throws -> FfiGitPushStats {
    return try FfiConverterTypeFfiGitPushStats.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiGitPushStats_lower(_ value: FfiGitPushStats) -> RustBuffer {
    return FfiConverterTypeFfiGitPushStats.lower(value)
}


/**
 * Input data for creating a new commit via FFI
 */
public struct FfiNewCommit {
    /**
     * Parent commit IDs
     */
    public var parentIds: [FfiCommitId]
    /**
     * Commit description/message
     */
    public var description: String
    /**
     * Author name (optional, uses settings default if not provided)
     */
    public var authorName: String?
    /**
     * Author email (optional, uses settings default if not provided)
     */
    public var authorEmail: String?
    /**
     * Author timestamp (optional, uses current time if not provided)
     */
    public var authorTimestamp: FfiTimestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Parent commit IDs
         */parentIds: [FfiCommitId], 
        /**
         * Commit description/message
         */description: String, 
        /**
         * Author name (optional, uses settings default if not provided)
         */authorName: String?, 
        /**
         * Author email (optional, uses settings default if not provided)
         */authorEmail: String?, 
        /**
         * Author timestamp (optional, uses current time if not provided)
         */authorTimestamp: FfiTimestamp?) {
        self.parentIds = parentIds
        self.description = description
        self.authorName = authorName
        self.authorEmail = authorEmail
        self.authorTimestamp = authorTimestamp
    }
}



extension FfiNewCommit: Equatable, Hashable {
    public static func ==(lhs: FfiNewCommit, rhs: FfiNewCommit) -> Bool {
        if lhs.parentIds != rhs.parentIds {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.authorName != rhs.authorName {
            return false
        }
        if lhs.authorEmail != rhs.authorEmail {
            return false
        }
        if lhs.authorTimestamp != rhs.authorTimestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(parentIds)
        hasher.combine(description)
        hasher.combine(authorName)
        hasher.combine(authorEmail)
        hasher.combine(authorTimestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiNewCommit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiNewCommit {
        return
            try FfiNewCommit(
                parentIds: FfiConverterSequenceTypeFfiCommitId.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                authorName: FfiConverterOptionString.read(from: &buf), 
                authorEmail: FfiConverterOptionString.read(from: &buf), 
                authorTimestamp: FfiConverterOptionTypeFfiTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FfiNewCommit, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFfiCommitId.write(value.parentIds, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.authorName, into: &buf)
        FfiConverterOptionString.write(value.authorEmail, into: &buf)
        FfiConverterOptionTypeFfiTimestamp.write(value.authorTimestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiNewCommit_lift(_ buf: RustBuffer) throws -> FfiNewCommit {
    return try FfiConverterTypeFfiNewCommit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiNewCommit_lower(_ value: FfiNewCommit) -> RustBuffer {
    return FfiConverterTypeFfiNewCommit.lower(value)
}


/**
 * Input data for rewriting an existing commit via FFI
 */
public struct FfiRewriteCommit {
    /**
     * The commit ID to rewrite
     */
    public var commitId: FfiCommitId
    /**
     * New description (optional, keeps original if not provided)
     */
    public var newDescription: String?
    /**
     * New parent IDs (optional, keeps original if not provided)
     */
    public var newParentIds: [FfiCommitId]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The commit ID to rewrite
         */commitId: FfiCommitId, 
        /**
         * New description (optional, keeps original if not provided)
         */newDescription: String?, 
        /**
         * New parent IDs (optional, keeps original if not provided)
         */newParentIds: [FfiCommitId]?) {
        self.commitId = commitId
        self.newDescription = newDescription
        self.newParentIds = newParentIds
    }
}



extension FfiRewriteCommit: Equatable, Hashable {
    public static func ==(lhs: FfiRewriteCommit, rhs: FfiRewriteCommit) -> Bool {
        if lhs.commitId != rhs.commitId {
            return false
        }
        if lhs.newDescription != rhs.newDescription {
            return false
        }
        if lhs.newParentIds != rhs.newParentIds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(commitId)
        hasher.combine(newDescription)
        hasher.combine(newParentIds)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiRewriteCommit: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiRewriteCommit {
        return
            try FfiRewriteCommit(
                commitId: FfiConverterTypeFfiCommitId.read(from: &buf), 
                newDescription: FfiConverterOptionString.read(from: &buf), 
                newParentIds: FfiConverterOptionSequenceTypeFfiCommitId.read(from: &buf)
        )
    }

    public static func write(_ value: FfiRewriteCommit, into buf: inout [UInt8]) {
        FfiConverterTypeFfiCommitId.write(value.commitId, into: &buf)
        FfiConverterOptionString.write(value.newDescription, into: &buf)
        FfiConverterOptionSequenceTypeFfiCommitId.write(value.newParentIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRewriteCommit_lift(_ buf: RustBuffer) throws -> FfiRewriteCommit {
    return try FfiConverterTypeFfiRewriteCommit.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiRewriteCommit_lower(_ value: FfiRewriteCommit) -> RustBuffer {
    return FfiConverterTypeFfiRewriteCommit.lower(value)
}


/**
 * A commit signature (author or committer) for FFI
 */
public struct FfiSignature {
    /**
     * Name of the person
     */
    public var name: String
    /**
     * Email address
     */
    public var email: String
    /**
     * Timestamp of the signature
     */
    public var timestamp: FfiTimestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Name of the person
         */name: String, 
        /**
         * Email address
         */email: String, 
        /**
         * Timestamp of the signature
         */timestamp: FfiTimestamp) {
        self.name = name
        self.email = email
        self.timestamp = timestamp
    }
}



extension FfiSignature: Equatable, Hashable {
    public static func ==(lhs: FfiSignature, rhs: FfiSignature) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.timestamp != rhs.timestamp {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(email)
        hasher.combine(timestamp)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiSignature {
        return
            try FfiSignature(
                name: FfiConverterString.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterTypeFfiTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: FfiSignature, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterTypeFfiTimestamp.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignature_lift(_ buf: RustBuffer) throws -> FfiSignature {
    return try FfiConverterTypeFfiSignature.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiSignature_lower(_ value: FfiSignature) -> RustBuffer {
    return FfiConverterTypeFfiSignature.lower(value)
}


/**
 * A timestamp for FFI
 */
public struct FfiTimestamp {
    /**
     * Milliseconds since Unix epoch
     */
    public var millisSinceEpoch: Int64
    /**
     * Timezone offset in minutes from UTC
     */
    public var tzOffsetMinutes: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Milliseconds since Unix epoch
         */millisSinceEpoch: Int64, 
        /**
         * Timezone offset in minutes from UTC
         */tzOffsetMinutes: Int32) {
        self.millisSinceEpoch = millisSinceEpoch
        self.tzOffsetMinutes = tzOffsetMinutes
    }
}



extension FfiTimestamp: Equatable, Hashable {
    public static func ==(lhs: FfiTimestamp, rhs: FfiTimestamp) -> Bool {
        if lhs.millisSinceEpoch != rhs.millisSinceEpoch {
            return false
        }
        if lhs.tzOffsetMinutes != rhs.tzOffsetMinutes {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(millisSinceEpoch)
        hasher.combine(tzOffsetMinutes)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFfiTimestamp: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FfiTimestamp {
        return
            try FfiTimestamp(
                millisSinceEpoch: FfiConverterInt64.read(from: &buf), 
                tzOffsetMinutes: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: FfiTimestamp, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.millisSinceEpoch, into: &buf)
        FfiConverterInt32.write(value.tzOffsetMinutes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTimestamp_lift(_ buf: RustBuffer) throws -> FfiTimestamp {
    return try FfiConverterTypeFfiTimestamp.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFfiTimestamp_lower(_ value: FfiTimestamp) -> RustBuffer {
    return FfiConverterTypeFfiTimestamp.lower(value)
}


/**
 * Unified error type exposed via FFI
 */
public enum JjError {

    
    
    case Workspace(message: String
    )
    case Repository(message: String
    )
    case Backend(message: String
    )
    case CommitNotFound(id: String
    )
    case InvalidArgument(message: String
    )
    case Revset(message: String
    )
    case Transaction(message: String
    )
    case Git(message: String
    )
    case Internal(message: String
    )
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJjError: FfiConverterRustBuffer {
    typealias SwiftType = JjError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JjError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Workspace(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .Repository(
            message: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Backend(
            message: try FfiConverterString.read(from: &buf)
            )
        case 4: return .CommitNotFound(
            id: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidArgument(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .Revset(
            message: try FfiConverterString.read(from: &buf)
            )
        case 7: return .Transaction(
            message: try FfiConverterString.read(from: &buf)
            )
        case 8: return .Git(
            message: try FfiConverterString.read(from: &buf)
            )
        case 9: return .Internal(
            message: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JjError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Workspace(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Repository(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Backend(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .CommitNotFound(id):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .InvalidArgument(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Revset(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Transaction(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Git(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .Internal(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


extension JjError: Equatable, Hashable {}

extension JjError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFfiTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = FfiTimestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFfiTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFfiTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeFfiCommitId: FfiConverterRustBuffer {
    typealias SwiftType = [FfiCommitId]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFfiCommitId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFfiCommitId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiCommit: FfiConverterRustBuffer {
    typealias SwiftType = [FfiCommit]

    public static func write(_ value: [FfiCommit], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiCommit.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiCommit] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiCommit]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiCommit.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFfiCommitId: FfiConverterRustBuffer {
    typealias SwiftType = [FfiCommitId]

    public static func write(_ value: [FfiCommitId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFfiCommitId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FfiCommitId] {
        let len: Int32 = try readInt(&buf)
        var seq = [FfiCommitId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFfiCommitId.read(from: &buf))
        }
        return seq
    }
}
/**
 * Get abandoned commit IDs from import stats
 */
public func getAbandonedCommitsFromImport(stats: FfiGitImportStats) -> [FfiCommitId] {
    return try!  FfiConverterSequenceTypeFfiCommitId.lift(try! rustCall() {
    uniffi_jj_ffi_fn_func_get_abandoned_commits_from_import(
        FfiConverterTypeFfiGitImportStats.lower(stats),$0
    )
})
}
/**
 * Initialize a new Git workspace with colocated Git backend
 */
public func initColocatedGitWorkspace(workspacePath: String, userName: String, userEmail: String)throws  -> FfiWorkspace {
    return try  FfiConverterTypeFfiWorkspace.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_func_init_colocated_git_workspace(
        FfiConverterString.lower(workspacePath),
        FfiConverterString.lower(userName),
        FfiConverterString.lower(userEmail),$0
    )
})
}
/**
 * Initialize a new Git workspace with internal Git backend
 */
public func initInternalGitWorkspace(workspacePath: String, userName: String, userEmail: String)throws  -> FfiWorkspace {
    return try  FfiConverterTypeFfiWorkspace.lift(try rustCallWithError(FfiConverterTypeJjError.lift) {
    uniffi_jj_ffi_fn_func_init_internal_git_workspace(
        FfiConverterString.lower(workspacePath),
        FfiConverterString.lower(userName),
        FfiConverterString.lower(userEmail),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_jj_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_jj_ffi_checksum_func_get_abandoned_commits_from_import() != 13864) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_func_init_colocated_git_workspace() != 43947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_func_init_internal_git_workspace() != 65260) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_commit() != 56256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_discard() != 20894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_export_refs() != 21078) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_fetch() != 59760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_import_refs() != 13678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffigittransaction_push_branches() != 31753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_count_revset() != 21946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_evaluate_revset() != 38673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_evaluate_revset_to_commits() != 24265) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_get_commit() != 24369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_resolve_change_id() != 25220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_resolve_commit_prefix() != 41711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_root_change_id() != 39873) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_root_commit() != 37001) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_root_commit_id() != 20442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_start_git_transaction() != 60704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffireadonlyrepo_start_transaction() != 62165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_abandon_commit() != 54462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_commit() != 970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_create_commit_from_parent() != 61685) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_create_empty_commit() != 52512) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_discard() != 47963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_has_changes() != 10126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_rewrite_commit() != 53958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffitransaction_update_description() != 43191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffiworkspace_repo() != 54533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffiworkspace_repo_path() != 45615) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_method_ffiworkspace_workspace_root() != 26542) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_jj_ffi_checksum_constructor_ffiworkspace_load() != 60897) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all